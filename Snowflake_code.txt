-- CREATE STAGE my_s3_stage
-- URL = "s3://json-csv-data-bucket/"
-- STORAGE_INTEGRATION = my_s3_integration;

CREATE STAGE my_s3_stage_2
URL = "s3://json-csv-data-bucket/"
STORAGE_INTEGRATION = my_s3_integration_2;

USE DATABASE SNOWFLAKE_LEARNING_DB;

-- CREATE STORAGE INTEGRATION my_s3_integration
-- TYPE = EXTERNAL_STAGE
-- ENABLED = TRUE
-- STORAGE_PROVIDER = S3 
-- STORAGE_ALLOWED_LOCATIONS = ("s3://json-csv-data-bucket/")
-- STORAGE_AWS_ROLE_ARN = "arn:aws:iam::173010302999:role/SNOWFLAKEROLE";

CREATE STORAGE INTEGRATION my_s3_integration_2
TYPE = EXTERNAL_STAGE
ENABLED = TRUE
STORAGE_PROVIDER = S3 
STORAGE_ALLOWED_LOCATIONS = ("s3://json-csv-data-bucket/")
STORAGE_AWS_ROLE_ARN = "arn:aws:iam::173010302999:role/RandomAccessRole";

DESCRIBE STORAGE INTEGRATION my_s3_integration_2;
SHOW STAGES;
ls @my_s3_stage_2;

-- SELECT $1
-- FROM @my_s3_stage_2/api1_3b975f68-f8ab-4e95-b96d-d59706135bd6.json
-- (FILE_FORMAT => (TYPE = JSON));

create file format my_json_format type = JSON;

select $1 from@my_s3_stage_2/api1_3b975f68-f8ab-4e95-b96d-d59706135bd6.json
(FILE_FORMAT => my_json_format);

create table crypto_raw (data VARIANT);

copy into crypto_raw from @my_s3_stage_2/api1_3b975f68-f8ab-4e95-b96d-d59706135bd6.json
FILE_FORMAT = my_json_format;

create view crypto_transformed as select t.value:id::string as id, t.value:symbol::string as symbol,t.value:name::string as name, t.value:price_usd::float as price_usd,ROUND(t.value:market_cap_usd::float / 1000000, 2) as market_cap_million,t.value:percent_change_24h::float as change_24h, 
case when t.value:percent_change_24h::float > 0 then 'UP'
else 'DOWN' 
end as trend_24h
from crypto_raw, lateral FLATTEN(input => data:data) t;

select * from crypto_raw;

select * from crypto_transformed limit 10;

create table exchange_raw(data VARIANT);

copy into exchange_raw from @my_s3_stage_2/api2_bb6a3499-995f-4051-82db-8543f68043a0.json
FILE_FORMAT = my_json_format;

create view exchange_transformed_2 as select t.value:Date::DATE as date,nullif(t.value:USD::string, -1) as usd, nullif(t.value:JPY::string, -1) as jpy, nullif(t.value:INR::STRING, -1) as inr,
case
when (nullif(t.value:USD::string, -1)) > 3 then 'HIGH' 
else 'NORMAL' 
end as is_usd_high from exchange_raw,lateral flatten(input => data) t;


select * from exchange_transformed_2 limit 10;